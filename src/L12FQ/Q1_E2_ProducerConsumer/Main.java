package L12FQ.Q1_E2_ProducerConsumer;

/*
    Gleb Stickily
        Просьба рассказать про методы notify\wait.
        И показать, как многопоточность применяется на пет-проектах
 */

/**
 * Notify
 */

/**
 * Как работают методы wait() и notify()/notifyAll()?
 *
 * Эти методы определены у класса Object и предназначены для взаимодействия
 * потоков между собой при межпоточной синхронизации.
 *
 * • wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор,
 *              пока другой поток не вызовет метод notify()/notifyAll();
 *
 * • notify(): продолжает работу потока, у которого ранее был вызван метод wait();
 *
 * • notifyAll(): возобновляет работу всех потоков, у которых ранее был вызван метод wait().
 *
 * Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит
 *  из состояния Работающий (Running) в состояние Ожидания (Waiting).
 *
 *
 *  Метод notify() подаёт сигнал одному из потоков, ожидающих на объекте,
 *  чтобы перейти в состояние Работоспособный (Runnable).
 *  При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным.
 *
 *
 *  Метод notifyAll() заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable).
 *  Если ни один поток не находится в ожидании на методе wait(), то при вызове notify() или notifyAll() ничего не происходит.
 *
 * Поток может вызвать методы wait() или notify() для определённого объекта, только если он в данный момент имеет блокировку на этот объект. wait(), notify() и notifyAll() должны вызываться только из синхронизированного кода.
 */

/**
 *  Статический метод Thread.yield() возвращает выполняющийся поток в состоянии runnable,
 *  для того чтобы уступить место другому потоку.
 */

public class Main {

    // https://metanit.com/java/tutorial/8.5.php

    public static void main(String[] args) {

        Store store = new Store();

        Producer producer = new Producer(store);
        Consumer consumer = new Consumer(store);

        new Thread(producer).start();
        new Thread(consumer).start();
    }
}
